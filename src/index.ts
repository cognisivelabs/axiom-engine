import * as fs from 'fs';
import * as path from 'path';
import { Lexer } from './parser/Lexer';
import { Parser } from './parser/Parser';
import { TypeChecker } from './checker/TypeChecker';
import { Interpreter } from './interpreter/Interpreter';
import { Statement, Type } from './common/AST';
import { ErrorReporter } from './common/ErrorReporter';
import { ContractDef, SchemaLoader } from './common/Contract';

export class Axiom {
    /**
     * Compiles the source code into an AST (Abstract Syntax Tree).
     * @param source The Axiom Rule Language (.arl) source string.
     * @param filename Optional filename for error reporting context.
     * @returns An array of Statements representing the AST.
     */
    static compile(source: string, filename?: string): Statement[] {
        const lexer = new Lexer(source);
        const tokens = lexer.tokenize();
        const parser = new Parser(tokens, filename);
        return parser.parse();
    }

    /**
     * Validates the AST against a Data Contract.
     * Ensures all variable references and types are correct before execution.
     * @param ast The AST generated by compile().
     * @param contract The Data Contract definition (Inputs/Outputs).
     * @param filename Optional filename for error reporting context.
     * @throws {AxiomError} If a type mismatch or undefined variable is found.
     */
    static check(ast: Statement[], contract: ContractDef, filename?: string): void {
        const checker = new TypeChecker();
        checker.check(ast, contract, filename);
    }

    /**
     * Executes the AST against a runtime data context.
     * @param ast The AST generated by compile().
     * @param contextData The actual data inputs (must match contract structure).
     * @returns The final result of the rule execution.
     */
    static execute(ast: Statement[], contextData: Record<string, any>): any {
        const interpreter = new Interpreter();
        return interpreter.interpret(ast, contextData);
    }

    /**
     * Convenience method to Compile, Check, and Execute in one go.
     * @param source The source code.
     * @param data The runtime input data.
     * @param contract The contract definition.
     * @param filename Optional filename.
     * @returns The execution result.
     */
    static eval(source: string, data: Record<string, any>, contract: ContractDef, filename?: string): any {
        const ast = this.compile(source, filename);
        this.check(ast, contract, filename);
        return this.execute(ast, data);
    }
}

// CLI Logic
if (require.main === module) {
    const args = process.argv.slice(2);
    if (args.length === 0) {
        console.log("Usage: axiom <script.arl> --contract <contract.json> --data <data.json>");
        process.exit(1);
    }

    const scriptPath = args[0];
    if (!scriptPath.endsWith('.arl')) {
        console.error("Error: Axiom rule files must have an '.arl' extension.");
        process.exit(1);
    }

    // Parse Flags
    let contractPath = '';
    let dataPath = '';

    for (let i = 1; i < args.length; i++) {
        if (args[i] === '--contract') contractPath = args[++i];
        if (args[i] === '--data') dataPath = args[++i];
    }

    if (!contractPath || !dataPath) {
        console.error("Error: --contract and --data arguments are required.");
        process.exit(1);
    }

    if (!fs.existsSync(scriptPath)) { console.error(`File not found: ${scriptPath}`); process.exit(1); }
    if (!fs.existsSync(contractPath)) { console.error(`File not found: ${contractPath}`); process.exit(1); }
    if (!fs.existsSync(dataPath)) { console.error(`File not found: ${dataPath}`); process.exit(1); }

    try {
        const source = fs.readFileSync(scriptPath, 'utf-8');
        const contract = SchemaLoader.load(contractPath);
        const data = JSON.parse(fs.readFileSync(dataPath, 'utf-8'));

        console.log("--- Axiom Engine ---");
        console.log(`Rule: ${path.basename(scriptPath)}`);
        console.log(`Contract: ${contract.name}`);
        console.log("--------------------");

        const result = Axiom.eval(source, data, contract, path.basename(scriptPath));

        console.log("[Verifying] Type Check Passed.");
        console.log("--------------------");
        console.log("Final Result:", result);
    } catch (e: any) {
        ErrorReporter.report(e);
        process.exit(1);
    }
}
